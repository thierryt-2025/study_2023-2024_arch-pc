     1                                  %include 'in_out.asm'
     1                              <1> ; in_out.asm
     2                              <1> section .text
     3                              <1> 
     4                              <1> ;------------------------------------------
     5                              <1> ; _sread - чтение строки из stdin
     6                              <1> ; ARGS: ECX = buffer, EDX = buffer size
     7                              <1> ;------------------------------------------
     8                              <1> _sread:
     9 00000000 50                  <1>     push    eax
    10 00000001 53                  <1>     push    ebx
    11 00000002 B803000000          <1>     mov     eax, 3      ; sys_read
    12 00000007 BB00000000          <1>     mov     ebx, 0      ; stdin
    13 0000000C CD80                <1>     int     0x80
    14 0000000E 5B                  <1>     pop     ebx
    15 0000000F 58                  <1>     pop     eax
    16 00000010 C3                  <1>     ret
    17                              <1> 
    18                              <1> ;------------------------------------------
    19                              <1> ; _swrite - запись строки в stdout
    20                              <1> ; ARGS: EAX = string pointer, EBX = string length
    21                              <1> ;------------------------------------------
    22                              <1> _swrite:
    23 00000011 50                  <1>     push    eax
    24 00000012 53                  <1>     push    ebx
    25 00000013 51                  <1>     push    ecx
    26 00000014 52                  <1>     push    edx
    27 00000015 89C1                <1>     mov     ecx, eax    ; string pointer
    28 00000017 89DA                <1>     mov     edx, ebx    ; string length
    29 00000019 B804000000          <1>     mov     eax, 4      ; sys_write
    30 0000001E BB01000000          <1>     mov     ebx, 1      ; stdout
    31 00000023 CD80                <1>     int     0x80
    32 00000025 5A                  <1>     pop     edx
    33 00000026 59                  <1>     pop     ecx
    34 00000027 5B                  <1>     pop     ebx
    35 00000028 58                  <1>     pop     eax
    36 00000029 C3                  <1>     ret
    37                              <1> 
    38                              <1> ;------------------------------------------
    39                              <1> ; sprint - вывод строки
    40                              <1> ; ARGS: EAX = string pointer (null-terminated)
    41                              <1> ;------------------------------------------
    42                              <1> sprint:
    43 0000002A 51                  <1>     push    ecx
    44 0000002B 52                  <1>     push    edx
    45 0000002C 53                  <1>     push    ebx
    46 0000002D 89C1                <1>     mov     ecx, eax    ; сохраняем указатель на строку
    47                              <1>     
    48                              <1>     ; вычисляем длину строки
    49 0000002F 31DB                <1>     xor     ebx, ebx    ; обнуляем счетчик
    50                              <1> .sprint_len_loop:
    51 00000031 803C1800            <1>     cmp     byte [eax+ebx], 0
    52 00000035 7403                <1>     je      .sprint_len_done
    53 00000037 43                  <1>     inc     ebx
    54 00000038 EBF7                <1>     jmp     .sprint_len_loop
    55                              <1> .sprint_len_done:
    56                              <1>     
    57                              <1>     ; выводим строку
    58 0000003A 89C8                <1>     mov     eax, ecx
    59 0000003C E8D0FFFFFF          <1>     call    _swrite
    60                              <1>     
    61 00000041 5B                  <1>     pop     ebx
    62 00000042 5A                  <1>     pop     edx
    63 00000043 59                  <1>     pop     ecx
    64 00000044 C3                  <1>     ret
    65                              <1> 
    66                              <1> ;------------------------------------------
    67                              <1> ; sprintLF - вывод строки с переводом строки
    68                              <1> ; ARGS: EAX = string pointer
    69                              <1> ;------------------------------------------
    70                              <1> sprintLF:
    71 00000045 E8E0FFFFFF          <1>     call    sprint
    72 0000004A 50                  <1>     push    eax
    73 0000004B B80A000000          <1>     mov     eax, 0Ah    ; символ перевода строки
    74 00000050 50                  <1>     push    eax
    75 00000051 89E0                <1>     mov     eax, esp    ; указатель на символ перевода строки
    76 00000053 BB01000000          <1>     mov     ebx, 1      ; длина = 1
    77 00000058 E8B4FFFFFF          <1>     call    _swrite
    78 0000005D 58                  <1>     pop     eax
    79 0000005E 58                  <1>     pop     eax
    80 0000005F C3                  <1>     ret
    81                              <1> 
    82                              <1> ;------------------------------------------
    83                              <1> ; sread - чтение строки
    84                              <1> ; ARGS: ECX = buffer, EDX = buffer size
    85                              <1> ;------------------------------------------
    86                              <1> sread:
    87 00000060 E89BFFFFFF          <1>     call    _sread
    88 00000065 C3                  <1>     ret
    89                              <1> 
    90                              <1> ;------------------------------------------
    91                              <1> ; iprint - вывод целого числа
    92                              <1> ; ARGS: EAX = integer
    93                              <1> ;------------------------------------------
    94                              <1> iprint:
    95 00000066 50                  <1>     push    eax
    96 00000067 51                  <1>     push    ecx
    97 00000068 52                  <1>     push    edx
    98 00000069 56                  <1>     push    esi
    99 0000006A B900000000          <1>     mov     ecx, 0      ; счетчик цифр
   100                              <1>     
   101                              <1> .divide_loop:
   102 0000006F 41                  <1>     inc     ecx          ; увеличиваем счетчик цифр
   103 00000070 BA00000000          <1>     mov     edx, 0       ; обнуляем edx для деления
   104 00000075 BE0A000000          <1>     mov     esi, 10      ; делитель
   105 0000007A F7FE                <1>     idiv    esi          ; eax = eax/10, edx = остаток
   106 0000007C 83C230              <1>     add     edx, 48      ; преобразуем остаток в ASCII
   107 0000007F 52                  <1>     push    edx          ; сохраняем цифру в стек
   108 00000080 83F800              <1>     cmp     eax, 0       ; проверяем, есть ли еще цифры
   109 00000083 75EA                <1>     jnz     .divide_loop
   110                              <1>     
   111                              <1> .print_loop:
   112 00000085 49                  <1>     dec     ecx          ; уменьшаем счетчик
   113 00000086 89E0                <1>     mov     eax, esp     ; указатель на цифру в стеке
   114 00000088 BB01000000          <1>     mov     ebx, 1       ; длина = 1
   115 0000008D E87FFFFFFF          <1>     call    _swrite      ; выводим цифру
   116 00000092 58                  <1>     pop     eax          ; убираем цифру из стека
   117 00000093 83F900              <1>     cmp     ecx, 0       ; проверяем, все ли цифры вывели
   118 00000096 75ED                <1>     jnz     .print_loop
   119                              <1>     
   120 00000098 5E                  <1>     pop     esi
   121 00000099 5A                  <1>     pop     edx
   122 0000009A 59                  <1>     pop     ecx
   123 0000009B 58                  <1>     pop     eax
   124 0000009C C3                  <1>     ret
   125                              <1> 
   126                              <1> ;------------------------------------------
   127                              <1> ; iprintLF - вывод целого числа с переводом строки
   128                              <1> ; ARGS: EAX = integer
   129                              <1> ;------------------------------------------
   130                              <1> iprintLF:
   131 0000009D E8C4FFFFFF          <1>     call    iprint
   132 000000A2 50                  <1>     push    eax
   133 000000A3 B80A000000          <1>     mov     eax, 0Ah    ; символ перевода строки
   134 000000A8 50                  <1>     push    eax
   135 000000A9 89E0                <1>     mov     eax, esp    ; указатель на символ перевода строки
   136 000000AB BB01000000          <1>     mov     ebx, 1      ; длина = 1
   137 000000B0 E85CFFFFFF          <1>     call    _swrite
   138 000000B5 58                  <1>     pop     eax
   139 000000B6 58                  <1>     pop     eax
   140 000000B7 C3                  <1>     ret
   141                              <1> 
   142                              <1> ;------------------------------------------
   143                              <1> ; atoi - преобразование строки в целое число
   144                              <1> ; ARGS: EAX = string pointer
   145                              <1> ; RET: EAX = integer
   146                              <1> ;------------------------------------------
   147                              <1> atoi:
   148 000000B8 53                  <1>     push    ebx
   149 000000B9 51                  <1>     push    ecx
   150 000000BA 52                  <1>     push    edx
   151 000000BB 56                  <1>     push    esi
   152 000000BC 89C6                <1>     mov     esi, eax    ; сохраняем указатель на строку
   153 000000BE B800000000          <1>     mov     eax, 0      ; обнуляем результат
   154 000000C3 B900000000          <1>     mov     ecx, 0      ; обнуляем счетчик
   155                              <1>     
   156                              <1> .multiply_loop:
   157 000000C8 31DB                <1>     xor     ebx, ebx    ; обнуляем ebx
   158 000000CA 8A1C0E              <1>     mov     bl, [esi+ecx] ; загружаем следующий символ
   159 000000CD 80FB30              <1>     cmp     bl, 48      ; сравниваем с '0'
   160 000000D0 7C1E                <1>     jl      .finished
   161 000000D2 80FB39              <1>     cmp     bl, 57      ; сравниваем с '9'
   162 000000D5 7F19                <1>     jg      .finished
   163 000000D7 80FB0A              <1>     cmp     bl, 10      ; проверяем на перевод строки
   164 000000DA 7414                <1>     je      .finished
   165 000000DC 80FB00              <1>     cmp     bl, 0       ; проверяем на конец строки
   166 000000DF 740F                <1>     jz      .finished
   167                              <1>     
   168 000000E1 80EB30              <1>     sub     bl, 48      ; преобразуем символ в число
   169 000000E4 01D8                <1>     add     eax, ebx    ; добавляем к результату
   170 000000E6 BB0A000000          <1>     mov     ebx, 10
   171 000000EB F7E3                <1>     mul     ebx         ; умножаем результат на 10
   172 000000ED 41                  <1>     inc     ecx         ; переходим к следующему символу
   173 000000EE EBD8                <1>     jmp     .multiply_loop
   174                              <1>     
   175                              <1> .finished:
   176 000000F0 BB0A000000          <1>     mov     ebx, 10
   177 000000F5 F7F3                <1>     div     ebx         ; делим на 10 (последнее умножение было лишним)
   178                              <1>     
   179 000000F7 5E                  <1>     pop     esi
   180 000000F8 5A                  <1>     pop     edx
   181 000000F9 59                  <1>     pop     ecx
   182 000000FA 5B                  <1>     pop     ebx
   183 000000FB C3                  <1>     ret
   184                              <1> 
   185                              <1> ;------------------------------------------
   186                              <1> ; quit - завершение программы
   187                              <1> ;------------------------------------------
   188                              <1> quit:
   189 000000FC B801000000          <1>     mov     eax, 1      ; sys_exit
   190 00000101 BB00000000          <1>     mov     ebx, 0      ; exit code
   191 00000106 CD80                <1>     int     0x80
     2                                  
     3                                  SECTION .text
     4                                  global _start
     5                                  
     6                                  _start:
     7 00000108 59                      pop ecx ; Извлекаем из стека в `ecx` количество аргументов
     8 00000109 5A                      pop edx ; Извлекаем из стека в `edx` имя программы
     9 0000010A 83E901                  sub ecx, 1 ; Уменьшаем `ecx` на 1 (без имени программы)
    10                                  
    11                                  next:
    12 0000010D 83F900                  cmp ecx, 0 ; проверяем, есть ли еще аргументы
    13 00000110 7408                    jz _end ; если аргументов нет выходим из цикла
    14 00000112 58                      pop eax ; иначе извлекаем аргумент из стека
    15 00000113 E82DFFFFFF              call sprintLF ; вызываем функцию печати
    16 00000118 E2F3                    loop next ; переход к обработке следующего аргумента
    17                                  
    18                                  _end:
    19 0000011A E8DDFFFFFF              call quit
